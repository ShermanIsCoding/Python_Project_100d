===本章概述===

本章将学习如下功能：

```
1. 慢查询分析：通过慢查询分析，找到有问题的命令进行优化
2. Redis Shell: 实用功能
3. Pipeline: 提高客户端性能
4. 事务与Lua: 制作自己的专属原子命令
5. Bitmaps: 通过在字符串数据结构上使用位操作，有效节省内存。
6. HyperLogLog: 一种基于概率的新算法，难以想象地节省内存空间。
7. 发布订阅： 消息通信机制
8. GEO： 基于地理位置信息的功能(Redis3.2)
```



===慢查询分析===

所谓慢查询分析就是系统在命令执行前后计算每条命令的执行时间，当超过预设阈值，就将这条

命令的相关信息，如发生时间，耗时，命令的详细信息记录下来。

发送命令->排队->执行命令->返回结果

需要注意的是，慢查询只统计【执行命令】的时间，所以没有慢查询并不代表客户端没有超时。

```
# 慢查询功能：
1. 预设阈值怎么设置？
2. 慢查询记录存放在哪里？
Redis提供了slowlog-log-slower-than和slowlog-max-len配置
slowlog-log-slower-than用来设置阈值，默认是10000微秒
设置为0会记录所有的命令，<0对于任何命令都不会记录，10000是超了会记录

而Redis使用了一个列表来存储慢查询日志，slowlog-max-len就是列表的最大长度
说明：一个新的命令满足慢查询条件时被插入到这个列表中，当慢查询日志列表已经
处于其最大长度时，最早插入的一个命令将从列表移除---队列

慢查询只记录命令执行时间，并不包括命令排队和网络传输时间。
由于慢查询日志是一个先进先出的队列，也就是说如果慢查询比较多的情况下，
可能会丢失部分慢查询命令，为了防止这种这种情况发生，可以定期执行slow get
命令将慢查询日志持久化到其他存储中。

```



===Redis Shell===

命令和参数比较多，用的时候再查询吧。。也记不住啊：）

===Pipeline===

```
原理：简单来说，这个跟网络传输的知识是相关的，也就是我们常说的流水量。
在1个RTT之内传输多个命令过去，使得效率大幅提升。想想TCP的流水线式永久连接传输。

注意：原生批量命令是原子的，而Pipeline是非原子。
原生批量命令是一个命令对应多个key
原生批量命令是Redis服务端支持实现的，而Pipeline需要服务端和客户端的共同实现。

```

===事务与Lua===

Redis提供了简单的事务功能，将一组需要一起执行的命令放到multi和exec两个命令之间。

multi命令代表事务开始，exec命令代表事务的结束。他们之间的命令是原子顺序执行的。

```
# Lua语言简介
1. 数据类型及其逻辑处理
	Lua语言提供了如下几种数据类型：booleans、numbers、string、tables
	local string val = "world"
	local tables myArray = {"redis", "python", "Java"}
	for i = 1, #myArray
	do
		print(myArray[i])
	end
2. 函数定义
	在Lua中，函数定义以function开头，以end结尾
	function funcName()
		...函数体...
	end
```

在Redis中使用Lua

```
# 两种方法

1. eval
eval 脚本内容 key个数 key列表 参数列表

2. evalsha
首先将Lua脚本加载到Redis服务端，得到该脚本的SHA1校验和
evalsha命令使用SHA1作为参数可以直接执行对应Lua脚本，避免每次发送
Lua脚本的开销。这样客户端就不需要每次执行脚本内容，而脚本也会常驻在
服务端，脚本功能得到了服务。
$ redis-cli script load "$(cat name.lua)"
"SHA1" -> 返回给你SHA1值
$ evalsha 脚本SHA1值 key个数 key列表 参数列表
```

===Bitmaps===

举个例子：

现代计算机用二进制位作为信息的基础单位，1个字节等于8位，例如big字符串是由3个字节组成

但实际计算机存储时将其用二进制表示，big分别对应ASCII码分别是98、105、103。

可以将Bitmaps想象成一个以位为单位的数组，数组的每个单元只能存储0和1，数组的下标在

Bitmaps中叫做偏移量。

===发布订阅===

Redis提供了基于发布/订阅模式的消息机制，此种模式下，消息发布者和订阅者不进行直接通信

，发布者客户端向指定的频道发布消息，订阅该频道的每个客户端都可以收到该消息。

注意：客户端在执行订阅命令之后进入了订阅状态，只能接收subscribe、psubscribe

unsubscribe、punsubscribe四个命令。

使用场景：聊天室、公告牌、服务之间利用消息解耦都可以使用发布订阅模式

===GEO===

Redis3.2提供了GEO功能，用来实现基于地理位置信息的应用，但是底层实现是zset